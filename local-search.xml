<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>EasyWeather Final Edition</title>
    <link href="/2024/03/19/EasyWeather/"/>
    <url>/2024/03/19/EasyWeather/</url>
    
    <content type="html"><![CDATA[<h1 id="EasyWeather-v1-0-10"><a href="#EasyWeather-v1-0-10" class="headerlink" title="EasyWeather v1.0.10"></a>EasyWeather v1.0.10</h1><p>EasyWeather采用Flutter为基础代码实现Material Design 3风格的天气预报软件。</p><p>天气数据均来源于高德开放平台与和风天气开放平台。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#%E8%AD%A6%E5%91%8A">⚠️警告</a></li><li><a href="#%E5%8A%9F%E8%83%BD">➡️功能</a></li><li><a href="#%E7%94%A8%E6%B3%95">🍜用法</a></li><li><a href="#%E9%A2%84%E8%A7%88">📷预览</a></li><li><a href="#%E4%B8%8B%E8%BD%BD">📥下载</a></li><li><a href="#%E8%AE%B8%E5%8F%AF%E8%AF%81">📝许可证</a></li></ul><h4 id="⚠️警告"><a href="#⚠️警告" class="headerlink" title="⚠️警告"></a>⚠️警告</h4><p>❗️仅适用于中国大陆与港澳台用户。</p><p>❗️仅适用于系统语言为简体中文。</p><p>❗️仅适用于搭载Android 9.0及以上的手机。</p><h4 id="➡️功能"><a href="#➡️功能" class="headerlink" title="➡️功能"></a>➡️功能</h4><p>☑️<br>目前天气查询<br>☑️<br>可存储的城市列表<br>☑️<br>未来三天的天气预报<br>☑️<br>可跟随天气变化的天气图标<br>☑️<br>深色模式（跟随系统设置）<br>☑️<br>危险天气预警<br>☑️<br>可跟随天气变化的天气背景<br>☑️<br>空气质量<br>☑️<br>天气指数</p><h4 id="🍜用法"><a href="#🍜用法" class="headerlink" title="🍜用法"></a>🍜用法</h4><ul><li>右上角可进行搜索城市（仅限于中文），搜索成功后会显示对应结果，选择想要的城市，单击后将返回主界面，显示天气情况并将其保存至城市列表中。</li><li>右上角可进行定位（需要定位权限），若定位成功则自动显示所在城市的天气情况，并保存至城市列表中。</li><li>右上角可选择已保存的城市，单击城市可查看城市的天气情况，长按可删除城市。</li><li>最顶部下拉可刷新天气情况。</li></ul><h4 id="📷预览"><a href="#📷预览" class="headerlink" title="📷预览"></a>📷预览</h4><p><img src="/images/blogimages/Sample_Dark.png" alt="图片展示"></p><p><img src="/images/blogimages/Sample_Light.png" alt="图片展示"></p><h4 id="📥下载"><a href="#📥下载" class="headerlink" title="📥下载"></a>📥下载</h4><p><a href="https://github.com/ClaretWheel1481/easyweather/releases/latest">点击此处</a></p><h4 id="📄许可证"><a href="#📄许可证" class="headerlink" title="📄许可证"></a>📄许可证</h4><p><a href="LICENSE">MIT</a> © Huang LinXing</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux Kernel</title>
    <link href="/2024/03/19/LinuxKernel/"/>
    <url>/2024/03/19/LinuxKernel/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-Kernel"><a href="#Linux-Kernel" class="headerlink" title="Linux Kernel"></a>Linux Kernel</h1><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>进程不仅仅局限于一段可执行的程序代码，还包含其他资源，如挂起的信号，内核的数据，处理器状态，一个或多个具有内存映射的内存地址空间以及一个或多个执行线程，存放全局变量的数据段等。</p><p><strong>进程就是正在执行的程序的代码的实时结果。</strong></p><p>线程是指进程中活动的对象，每个线程都有一个独立的程序计数器、进程栈还有一组进程寄存器。</p><p>内核调度的对象是线程，而在传统Unix系统中，<strong>一个进程仅仅包含一个线程</strong>，对于Linux而言，线程只是一种特殊的进程。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ Linux服务器多线程开发 - C++11线程类(1)</title>
    <link href="/2024/03/07/C++ThreadNotes_Thread/"/>
    <url>/2024/03/07/C++ThreadNotes_Thread/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>在C++中多线程的实现方法有POSIX与C++11自带库，在本文中将使用Thread方法。</p><h1 id="THREAD"><a href="#THREAD" class="headerlink" title="THREAD"></a>THREAD</h1><h4 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="THREAD多线程函数基础API"><a href="#THREAD多线程函数基础API" class="headerlink" title="THREAD多线程函数基础API"></a>THREAD多线程函数基础API</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">thread</span>() <span class="hljs-comment">//默认构造函数</span><br><span class="hljs-built_in">get_id</span>() <span class="hljs-comment">//获取线程ID</span><br><span class="hljs-built_in">joinable</span>() <span class="hljs-comment">//判断线程是否可连接</span><br><span class="hljs-built_in">join</span>()  <span class="hljs-comment">//等待线程结束(阻塞函数)</span><br><span class="hljs-built_in">detach</span>() <span class="hljs-comment">//使线程与当前线程分离</span><br><span class="hljs-built_in">native_handle</span>() <span class="hljs-comment">//获取线程句柄(需要本地库支持)</span><br><span class="hljs-built_in">swap</span>() <span class="hljs-comment">//交换两个线程</span><br></code></pre></td></tr></table></figure><h4 id="创建线程函数"><a href="#创建线程函数" class="headerlink" title="创建线程函数"></a>创建线程函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//批量创建线程对象，但是现在它还不会执行线程</span><br>std::thread threads[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span> <span class="hljs-comment">//Linux系统下的函数库，sleep()需要用到</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thfunc</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;in threadfunction：&quot;</span> &lt;&lt; n &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::thread threads[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        threads[i] = std::<span class="hljs-built_in">thread</span>(thfunc, i);<br>        <span class="hljs-comment">//thread(thfunc,i)的意思是创建一个线程对象，并调用thfunc函数，并将i作为参数传递给该函数</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        threads[i].<span class="hljs-built_in">join</span>();<br>    &#125;<span class="hljs-comment">//等待所有线程执行完毕</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;所有线程加载完毕！&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//等待1秒，让线程有足够的时间输出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码会输出如下：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">in threadfunction</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0</span><br><span class="hljs-attribute">in threadfunction</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><span class="hljs-attribute">in threadfunction</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><span class="hljs-attribute">in threadfunction</span><span class="hljs-punctuation">:</span> <span class="hljs-string">3</span><br><span class="hljs-attribute">in threadfunction</span><span class="hljs-punctuation">:</span> <span class="hljs-string">4</span><br>所有线程加载完毕！<br></code></pre></td></tr></table></figure><h1 id="yield-以线程赛跑举例"><a href="#yield-以线程赛跑举例" class="headerlink" title="yield() - 以线程赛跑举例"></a>yield() - 以线程赛跑举例</h1><p>yield()函数用于线程调度，让出CPU时间片，让其他线程先执行。</p><h4 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span>   <span class="hljs-comment">//原子操作库，保证线程安全</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">atomic&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">ready</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;  <span class="hljs-comment">//定义一个全局原子变量，用于线程同步</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thfunc</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (!ready) &#123;<br>        this_thread::<span class="hljs-built_in">yield</span>();  <span class="hljs-comment">//当ready为false时，让出CPU时间片</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>;++i) &#123;&#125;  <br>    <span class="hljs-comment">//执行一些耗时的操作,volatile的意思是避免编译器对这段代码进行优化，确保每次都从内存中读取变量的值</span><br>    cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    thread threads[<span class="hljs-number">10</span>]; <span class="hljs-comment">//定义10个线程对象</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;10个线程赛跑排名(线程id)：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        threads[i] = <span class="hljs-built_in">thread</span>(thfunc, i); <span class="hljs-comment">//启动线程并分配id</span><br>    &#125;<br>    ready = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; th : threads)<br>        th.<span class="hljs-built_in">join</span>();  <span class="hljs-comment">//等待所有线程执行完毕</span><br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码会输出如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">10</span>个线程赛跑排名(线程id)：<br><span class="hljs-attribute">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>每次结果可能都不同，因为线程调度是随机的。<br>但是若出现顺序错乱，则可能是因为远程调试的延迟问题。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Rust笔记</title>
    <link href="/2023/05/15/MyRustNotes/"/>
    <url>/2023/05/15/MyRustNotes/</url>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Rust是强类型语言，如果要声明变量，需要使用”let”关键字。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">123</span>;    <span class="hljs-comment">//其中，加上“mut”时变量才可被修改。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">b</span> = <span class="hljs-number">124</span>;<br>    <span class="hljs-comment">//此时a的值无法进行修改，会出错。</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;b&#125;&quot;</span>);<br>    b = <span class="hljs-number">125</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;b&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码将会输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">124<br>125<br></code></pre></td></tr></table></figure><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span> = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);    <span class="hljs-comment">//创建了一个元组绑定在tup上</span><br>    <span class="hljs-comment">//使用了 let 和一个模式将 tup 分成了三个不同的变量，x、y、z</span><br>    <span class="hljs-keyword">let</span> (x, y, z) = tup;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;y&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码会输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">6</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="数组-非vector"><a href="#数组-非vector" class="headerlink" title="数组(非vector)"></a>数组(非vector)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = a[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">second</span> = a[<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;first&#125;&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;second&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码会输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br></code></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="Loop"><a href="#Loop" class="headerlink" title="Loop"></a>Loop</h3><p>loop关键字将使代码一遍又一遍的执行，直到用户使用 停止 操作。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">loop</span>&#123;<br>        <span class="hljs-title function_ invoke__">println</span>(<span class="hljs-string">&quot;This is a loop!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码会输出：(3次后按下 Ctrl+C 使其停止)</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-string">&quot;This is a loop!&quot;</span><br><span class="hljs-string">&quot;This is a loop!&quot;</span><br><span class="hljs-string">&quot;This is a loop!&quot;</span><br><span class="hljs-symbol">^C</span><br></code></pre></td></tr></table></figure><h3 id="For"><a href="#For" class="headerlink" title="For"></a>For</h3><p>for循环遍历集合中的元素例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">elemt</span> <span class="hljs-keyword">in</span> a &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the a&#x27;s elements is &#123;elemt&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码会输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">10<br>20<br>30<br>40<br>50<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ Linux服务器多线程开发 - POSIX</title>
    <link href="/2023/04/24/C++ThreadNotes/"/>
    <url>/2023/04/24/C++ThreadNotes/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>在C++中多线程的实现方法有POSIX与C++11自带库，在本文中将使用POSIX方法。</p><h1 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h1><h4 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="POSIX多线程函数基础API"><a href="#POSIX多线程函数基础API" class="headerlink" title="POSIX多线程函数基础API"></a>POSIX多线程函数基础API</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">pthread_create</span>()    <span class="hljs-comment">//创建进程</span><br><span class="hljs-built_in">pthread_exit</span>()    <span class="hljs-comment">//线程终止自身执行</span><br><span class="hljs-built_in">pthread_join</span>()    <span class="hljs-comment">//等待一个线程的结束</span><br><span class="hljs-built_in">pthread_self</span>()    <span class="hljs-comment">//返回线程ID</span><br><span class="hljs-built_in">pthread_cancel</span>()  <span class="hljs-comment">//取消另外一个线程</span><br><span class="hljs-built_in">pthread_kill</span>()    <span class="hljs-comment">//向线程发送信号</span><br></code></pre></td></tr></table></figure><h4 id="创建线程函数"><a href="#创建线程函数" class="headerlink" title="创建线程函数"></a>创建线程函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *pid,<span class="hljs-type">const</span> pthread_attr_r *attr,<span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span> *),<span class="hljs-type">void</span> *arg)</span></span>;<br></code></pre></td></tr></table></figure><p>参数pid为指针，指向创建完成之后的线程ID。<br>pthread_t为unsigned long int类型。<br>attr指向线程属性结构，为pthread_attr_r的指针。<br>start_routine指向线程函数的地址。<br>arg指向传给线程函数的参数，成功为0;</p><h4 id="pthread-join的作用"><a href="#pthread-join的作用" class="headerlink" title="pthread_join的作用"></a>pthread_join的作用</h4><p>pthread_create创建完线程后，主线程仍然会执行pthread_create后面的代码，就会导致主程序已经结束了但是子线程还未创建完的情况出现，所以就需要让主线程等待，所以pthread_join则为阻塞函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> pid,<span class="hljs-type">void</span> ** value_ptr)</span></span>;<br></code></pre></td></tr></table></figure><p>value_ptr通常可以为NULL，若不为NULL，则pthread_t会复制一份线程退出值去内存区域内，并让*value_ptr指向该内存区域，所以pthread_join还能获得子线程的返回值。</p><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">threadfunction</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> <span class="hljs-comment">//线程函数</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;in threadfunction&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">pthread_t</span> tidp;<br>    <span class="hljs-type">int</span> ret;<br>    ret = <span class="hljs-built_in">pthread_create</span>(&amp;tidp, <span class="hljs-literal">NULL</span>, threadfunction, <span class="hljs-literal">NULL</span>);    <span class="hljs-comment">//创建线程</span><br>    <span class="hljs-keyword">if</span> (ret)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;pthread_create failed:&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">//main线程挂起1秒，让子线程有机会执行。</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;in main thread created.&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码会输出如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">in threadfunction<br>in main thread created.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ Stack、Queue使用方法</title>
    <link href="/2023/04/11/C++StackQueueNotes/"/>
    <url>/2023/04/11/C++StackQueueNotes/</url>
    
    <content type="html"><![CDATA[<h1 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h1><p>先进后出，当想访问栈内某一元素时，必须将其顶部的元素都弹出出栈后，才能访问该元素。</p><h1 id="栈Stack使用方法"><a href="#栈Stack使用方法" class="headerlink" title="栈Stack使用方法"></a>栈Stack使用方法</h1><h5 id="首先导入库与定义"><a href="#首先导入库与定义" class="headerlink" title="首先导入库与定义"></a>首先导入库与定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stack&lt;type_name&gt; name;<br>    <span class="hljs-comment">//type_name可以是任何基本类型、结构体</span><br>    <span class="hljs-comment">//也可以是STL标准容器如queue、set、vector</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="常用的使用方法"><a href="#常用的使用方法" class="headerlink" title="常用的使用方法"></a>常用的使用方法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//移除栈顶元素</span><br>stack.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">//返回是否为空的布尔值</span><br>stack.<span class="hljs-built_in">empty</span>();<br><span class="hljs-comment">//栈顶添加元素,*代指元素</span><br>stack.<span class="hljs-built_in">push</span>(*);<br><span class="hljs-comment">//返回stack中元素的个数</span><br>stack.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//返回栈顶元素</span><br>stack.<span class="hljs-built_in">top</span>();<br></code></pre></td></tr></table></figure><h1 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h1><p>先进入队列的先出去，后进入队列的后出去。必须从队尾插入新元素，队列中的元素只能从队首出。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ Set、Map使用方法</title>
    <link href="/2023/03/08/C++MapSetNotes/"/>
    <url>/2023/03/08/C++MapSetNotes/</url>
    
    <content type="html"><![CDATA[<h1 id="Map与Unordered-map的区别？"><a href="#Map与Unordered-map的区别？" class="headerlink" title="Map与Unordered_map的区别？"></a>Map与Unordered_map的区别？</h1><p>map：基于红黑树，元素有序存储</p><p>unordered_map：基于散列表，元素无序存储</p><p>在需要<strong>元素有序性</strong>或者对<strong>单次查询性能</strong>要求较为敏感时，请使用<strong>map</strong>，其余情况下应使用<strong>unordered_map</strong>，<strong>算法</strong>中更多的使用<strong>unordered_map</strong>。</p><h4 id="Set与Map的区别？"><a href="#Set与Map的区别？" class="headerlink" title="Set与Map的区别？"></a>Set与Map的区别？</h4><p><a href = "https://blog.csdn.net/zzzlln/article/details/122113934">点击进入查看详细</a></p><h4 id="HashMap使用方法"><a href="#HashMap使用方法" class="headerlink" title="HashMap使用方法"></a>HashMap使用方法</h4><p>首先导入库（map）及定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    map&lt;<span class="hljs-type">int</span>, string&gt; hashmap;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id = "insertmap"></h4><h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//三种方法，方法一 insert：</span><br>hashmap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,string&gt;(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;这是1&quot;</span>));<br><span class="hljs-comment">//方法二：</span><br>hashmap.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>,string&gt;::<span class="hljs-built_in">value_type</span> (<span class="hljs-number">2</span>,<span class="hljs-string">&quot;这是2&quot;</span>));<br><span class="hljs-comment">//方法三：</span><br>hashmap[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;这是3&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="遍历元素（C-11）"><a href="#遍历元素（C-11）" class="headerlink" title="遍历元素（C++ 11）"></a>遍历元素（C++ 11）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : hashmap)&#123;<br>    cout &lt;&lt; i.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i.second &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中i.first返回的是key值，i.second返回的是key值对应的value值。</p><h1 id="HashMap-unordered-map-使用方法"><a href="#HashMap-unordered-map-使用方法" class="headerlink" title="HashMap(unordered_map)使用方法"></a>HashMap(unordered_map)使用方法</h1><h4 id="首先导入库"><a href="#首先导入库" class="headerlink" title="首先导入库"></a>首先导入库</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>,string&gt; umap;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="#insertmap">插入元素、遍历（方法相同，点击跳转）</a></p><h1 id="HashSet使用方法"><a href="#HashSet使用方法" class="headerlink" title="HashSet使用方法"></a>HashSet使用方法</h1><h4 id="首先导入库-set-与定义"><a href="#首先导入库-set-与定义" class="headerlink" title="首先导入库(set)与定义"></a>首先导入库(set)与定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    set&lt;<span class="hljs-type">char</span>&gt; set1;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id = "insertset"></h4><h4 id="插入元素-1"><a href="#插入元素-1" class="headerlink" title="插入元素"></a>插入元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//例如我有一个 string TestCase= “Hello”</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : TestCase)&#123;<br>    set1.<span class="hljs-built_in">insert</span>(c);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : set1)&#123;<br>    cout &lt;&lt; c;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="此时会发现输出了“Helo”，Set作用之一便是去重。"><a href="#此时会发现输出了“Helo”，Set作用之一便是去重。" class="headerlink" title="此时会发现输出了“Helo”，Set作用之一便是去重。"></a>此时会发现输出了“Helo”，Set作用之一便是去重。</h4><h1 id="HashSet-unorderd-set-使用方法"><a href="#HashSet-unorderd-set-使用方法" class="headerlink" title="HashSet(unorderd_set)使用方法"></a>HashSet(unorderd_set)使用方法</h1><h4 id="导入库与定义"><a href="#导入库与定义" class="headerlink" title="导入库与定义"></a>导入库与定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unorderd_set&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    unorderd_set&lt;<span class="hljs-type">char</span>&gt; uset;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入元素、遍历（方法相同，点击跳转）"><a href="#插入元素、遍历（方法相同，点击跳转）" class="headerlink" title="插入元素、遍历（方法相同，点击跳转）"></a><a href="#insertset">插入元素、遍历（方法相同，点击跳转）</a></h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java算法笔记（OUT）</title>
    <link href="/2023/01/08/MyJavaNotes/"/>
    <url>/2023/01/08/MyJavaNotes/</url>
    
    <content type="html"><![CDATA[<h1 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h1><h6 id="字符串（常用）："><a href="#字符串（常用）：" class="headerlink" title="字符串（常用）："></a>字符串（常用）：</h6><h4 id="substring：分割字符串。"><a href="#substring：分割字符串。" class="headerlink" title="substring：分割字符串。"></a>substring：分割字符串。<br></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">Example</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Caseinpoint&quot;</span>;<br>System.out.println(Example.substring(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>上方代码输出的结果是“Ca”，以此类推。<br><br></p><h4 id="equals：字符串对比。"><a href="#equals：字符串对比。" class="headerlink" title="equals：字符串对比。"></a>equals：字符串对比。<br></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">word1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">word2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>System.out.println(word2.substring(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>).equals(word1));<br></code></pre></td></tr></table></figure><p>上方代码输出的结果是“true”。<br><br></p><h4 id="toString-：输出字符串数组。"><a href="#toString-：输出字符串数组。" class="headerlink" title="toString( )：输出字符串数组。"></a>toString( )：输出字符串数组。<br></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">String[] words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;Words1&quot;</span>,<span class="hljs-string">&quot;Words2&quot;</span>&#125;; <br>System.out.println(words.toString());<br></code></pre></td></tr></table></figure><p>上方代码输出的结果是“[Words1, Words2]”。<br><br></p><h4 id="toCharArray-：转换字符串为字符数组。"><a href="#toCharArray-：转换字符串为字符数组。" class="headerlink" title="toCharArray( )：转换字符串为字符数组。"></a>toCharArray( )：转换字符串为字符数组。<br></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>; <br><span class="hljs-type">char</span>[] words = word.toCharArray();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> i : words) &#123;<br>System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>上方代码输出的结果是“H、e、l、l、o”,此处顿号代表换行。<br><br></p><h6 id="字符（常用）："><a href="#字符（常用）：" class="headerlink" title="字符（常用）："></a>字符（常用）：</h6><h4 id="Character-isDigit：判断字符是否为数字。"><a href="#Character-isDigit：判断字符是否为数字。" class="headerlink" title="Character.isDigit：判断字符是否为数字。"></a>Character.isDigit：判断字符是否为数字。<br></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">char</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;T&#x27;</span>;<br>System.out.println(Character.isDigit(A));<br>System.out.println(Character.isDigit(B));<br></code></pre></td></tr></table></figure><p>上方代码输出的结果是“true与false”。<br><br></p><h6 id="哈希表："><a href="#哈希表：" class="headerlink" title="哈希表："></a>哈希表：</h6><h4 id="HashMap使用方法："><a href="#HashMap使用方法：" class="headerlink" title="HashMap使用方法："></a>HashMap使用方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-number">1.</span> Map&lt;Integer, String&gt; Sites = Map.of(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">2</span>,<span class="hljs-string">&quot;Nihao&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Hola&quot;</span>);<br><br><span class="hljs-number">2.</span> HashMap&lt;Integer, String&gt; Sites = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, String&gt;();<br>   Sites.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Hello&quot;</span>);<br>   Sites.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Nihao&quot;</span>);<br>   Sites.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Hola&quot;</span>);<br></code></pre></td></tr></table></figure><p>如以上两种方法所示，以打印的方式输出后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">System.out.println(Sites);<br></code></pre></td></tr></table></figure><p>结果都是同样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">&#123;<span class="hljs-number">1</span>=Hello, <span class="hljs-number">2</span>=Nihao, <span class="hljs-number">3</span>=Hola&#125;<br></code></pre></td></tr></table></figure><p>Hashmap访问(结果为”Nihao”)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">System.out.println(Sites.get(<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>Hashmap移除元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">Sites.remove(<span class="hljs-number">2</span>);<br>System.out.println(Sites);<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">&#123;<span class="hljs-number">1</span>=Hello,<span class="hljs-number">3</span>=Hola&#125;<br></code></pre></td></tr></table></figure><br>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Steam饰品搬砖手动选品利润计算器 v0.9.6 发布</title>
    <link href="/2022/09/20/ManualSelectionTool096/"/>
    <url>/2022/09/20/ManualSelectionTool096/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Steam饰品搬砖？"><a href="#什么是Steam饰品搬砖？" class="headerlink" title="什么是Steam饰品搬砖？"></a>什么是Steam饰品搬砖？</h2><p>Steam饰品搬砖就是通过第三方折扣后购买Steam美金余额卡，充值Steam余额，进行大批量饰品购买，再通过国内第三方交易平台以正常价售出；其软件则计算该过程中赚取的差价，简单的说就是，低价买入高价售出，称作为搬砖。</p><hr><h4 id="软件截图："><a href="#软件截图：" class="headerlink" title="软件截图："></a>软件截图：</h4><p><img src="/images/blogimages/mst096.png" alt="软件截图"></p><hr><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>1.若在使用时发现错误，请在Issues报告，可能会尽快修复。</p><p>2.实时美元汇率为1美元的当前汇率；充值折扣请按照小数点方式填写,例如7折请填”0.7”或”0.70”；Buff出售价格以及Steam购入价格请按照美元的价格填写。</p><p>3.利润算法仅靠自己研究发现，不保证100%准确，造成任何经济损失请自行承担。</p><p>4.该软件由Python Tkinter提供GUI，完全开源，仅提供计算“Steam饰品搬砖商品选择上的利润”,不涉及任何利益！</p><hr><h4 id="v0-9-6更新日志："><a href="#v0-9-6更新日志：" class="headerlink" title="v0.9.6更新日志："></a>v0.9.6更新日志：</h4><p>1.优化代码逻辑，修复了启动提示选择“否”时出现报错</p><p>2.新增”启动提示”</p><p>3.修改API源,优化了不同网络访问速度</p><p>4.额外添加了1条备用API</p><p>5.添加应用Logo</p><hr><h4 id="已知Bug"><a href="#已知Bug" class="headerlink" title="已知Bug:"></a>已知Bug:</h4><p>1.短期内多次打开应用可能会出现错误(尽量避免反复多次打开，新的汇率API有限制)</p><hr><h4 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h4><p><a href="https://github.com/ClaretWheel1481/Manual-Selection-Tool-Python-Version/releases">Github</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记本处理器优化[Intel]</title>
    <link href="/2022/08/04/LaptopOpt/"/>
    <url>/2022/08/04/LaptopOpt/</url>
    
    <content type="html"><![CDATA[<p>随着时间推移，笔记本逐渐成为人们生活中的一部分。而随着处理器厂商之间的内卷，性能增强的代价则是越来越高的发热与功耗。而这一篇文章，讲述的则是如何使Intel移动端处理器在合适的场合拥有合适的性能与功耗。</p><h4 id="软件部分："><a href="#软件部分：" class="headerlink" title="软件部分："></a>软件部分：</h4><p>此处以”i5-11400H”作为演示（每颗CPU设置也许不同，仅作为参考）</p><p>下滑找到下方三栏分别为：</p><p>1.Turbo Boost Short Power Max</p><p>2.Turbo Boost Power Max</p><p>3.Turbo Boost Power Time Window</p><p><img src="/images/blogimages/XTU.png" alt="图片展示"></p><p>在这里，我们仅需要调整第2条 - Turbo Boost Power Max</p><p>根据不同场景限制其功耗，能够有效降低温度，且也有所需要的性能。</p><p>以“原神”为例（原神锁60FPS不需要太多性能）：</p><p>我将 Turbo Boost Power Max 功耗设置为“Unlimited”，此时游戏帧数处于60FPS，但温度已经上了75度，且风扇呼呼的转。</p><p><img src="/images/blogimages/GUnlimited.png" alt="图片展示"></p><p>而将 Turbo Boost Power Max 功耗限制为“12.000W”，而此时游戏帧数仍然处于60FPS，整体功耗都下来了且安静许多。</p><p><img src="/images/blogimages/Glimited.png" alt="图片展示"></p><h4 id="硬件部分："><a href="#硬件部分：" class="headerlink" title="硬件部分："></a>硬件部分：</h4><p>要想拥有更好的性能与更低的发热，更换硅脂也是一个好方法。</p><p>笔记本出厂涂抹的硅脂大部分导热性能都比较差，此处推荐几个平价硅脂或相变片，笔记本对应型号更换教程也可以在网络上查询。</p><p><em>Arctic MX-4</em></p><p><em>信越 7921 &#x2F; 7868</em></p><p><em>利民 TF7</em></p><p><em>霍尼韦尔 7950 相变片</em></p><p>注意：使用相变片刚开始温度会较高，但是随着时间增长温度会下降到一定程度，效果可能比硅脂更好。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Steam饰品搬砖手动选品利润计算器 v0.9.4 发布</title>
    <link href="/2022/08/04/ManualSelectionTool094/"/>
    <url>/2022/08/04/ManualSelectionTool094/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Steam饰品搬砖？"><a href="#什么是Steam饰品搬砖？" class="headerlink" title="什么是Steam饰品搬砖？"></a>什么是Steam饰品搬砖？</h2><p>Steam饰品搬砖就是通过第三方折扣后购买Steam美金余额卡，充值Steam余额，进行大批量饰品购买，再通过国内第三方交易平台以正常价售出；其软件则计算该过程中赚取的差价，简单的说就是，低价买入高价售出，称作为搬砖。</p><hr><h4 id="软件截图："><a href="#软件截图：" class="headerlink" title="软件截图："></a>软件截图：</h4><p><img src="/images/blogimages/mst094.png" alt="软件截图"></p><hr><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>1.请尽量在中国互联网的环境下打开该软件(或暂停使用VPN)，否则将启动速度缓慢或无法正常打开(用于查询当前时间的美元汇率)。</p><p>2.若在使用时发现错误，请在Issues报告，可能会尽快修复。</p><p>3.实时美元汇率为1美元的当前汇率；充值折扣请按照小数点方式填写,例如7折请填”0.7”或”0.70”；Buff出售价格以及Steam购入价格请按照美元的价格填写。</p><p>4.利润算法仅靠自己研究发现，不保证100%准确，造成任何经济损失请自行承担。</p><p>5.该软件由Python Tkinter提供GUI，完全开源，仅提供计算“Steam饰品搬砖商品选择上的利润”,不涉及任何利益！</p><hr><h4 id="v0-9-4更新日志："><a href="#v0-9-4更新日志：" class="headerlink" title="v0.9.4更新日志："></a>v0.9.4更新日志：</h4><p>1.移除Random库,加速启动。</p><p>2.小幅度优化GUI。</p><hr><h4 id="已知Bug"><a href="#已知Bug" class="headerlink" title="已知Bug:"></a>已知Bug:</h4><p>1.短期内多次打开应用可能会出现错误(尽量避免反复多次打开，新的汇率API有限制)</p><hr><h4 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h4><p><a href="https://github.com/ClaretWheel1481/Manual-Selection-Tool-Python-Version/releases/tag/v0.9.4">Github</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于我的Firefox配置</title>
    <link href="/2022/08/04/AboutMyFirefox/"/>
    <url>/2022/08/04/AboutMyFirefox/</url>
    
    <content type="html"><![CDATA[<p>Firefox我最喜欢的地方就是它的开源与高度自定义；以下则是我对Firefox进行的部分配置。</p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>我最喜欢且常用的插件是 <em><strong>ublock Origin</strong></em> 与 <em><strong>Dark Reader</strong></em>。</p><ul><li><em>ublock Origin</em></li></ul><p>Firefox自带的跟踪保护，却没有广告拦截功能，而 <em>ublock Origin</em> 恰好弥补了这个缺点，它体积小还支持导入规则或自定义，优化加载网页的速度。</p><p>附上整合了乘风视频广告过滤规则、EasylistChina、EasylistLite、CJX’sAnnoyance的规则：</p><p><code>https://cdn.jsdelivr.net/gh/o0HalfLife0o/list@master/ad.txt</code></p><ul><li><em>Dark Reader</em></li></ul><p>Dark Reader让我在浏览网页时，减轻了我的眼睛负担。</p><p>我时常在深夜开着一盏台灯浏览密密麻麻的资料，系统主题为深色，而打开的部分网页却是白色，非常瞎眼，而这个插件则可以动态识别网页元素并修改为合适的深色，不仅如此还可以修改网页字体并加粗；还有很多功能都非常实用，也不会吃很多性能，值得推荐。</p><p><img src="/images/blogimages/darkreader.png" alt="图片展示"></p><h2 id="About-config"><a href="#About-config" class="headerlink" title="About:config"></a>About:config</h2><ul><li><em><strong>页面滚动</strong></em></li></ul><p>我一直觉得Firefox的页面滚动异常让我不舒服，隔壁Edge的页面滚动轻快但是油腻，直到我在Firefox的配置中发现了一个选项，打开后让Firefox实现了拥有Edge的轻快还没了Edge的油腻。</p><p>在地址栏中输入about:config后，再搜索：</p><p><code>general.smoothScroll.msdPhysics.enabled</code></p><p>将 <em>False</em> 修改为 <em>True</em> </p><p>之后用滚轮滚动页面会发现十分跟手！</p><ul><li><em><strong>字体渲染</strong></em></li></ul><p>Firefox渲染出的字体在1080p下比Chromium系渲染出的字体要粗且更清晰，但是我还想更好，于是经过我的不断搜索挖掘中发现：</p><p>在地址栏中输入about:config后，再搜索：</p><p><code>gfx.font_rendering.cleartype_params.rendering_mode</code></p><p>将数值改为 <em>5</em></p><p><code>0=default，1=aliased，2=GDI Classic，3=GDI Natural，4=Natural，5=Natural Symmetric</code></p><p>你会发现字体渲染与Linux平台的Firefox中字体十分相似，对我而言看着更舒服。</p><p>如果想要更好的效果，可以尝试搭配<a href="https://github.com/snowie2000/mactype">Mactype</a>实现“Mac”的字体渲染。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
