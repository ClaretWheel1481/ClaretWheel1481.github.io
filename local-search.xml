<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rust笔记</title>
    <link href="/2023/05/15/MyRustNotes/"/>
    <url>/2023/05/15/MyRustNotes/</url>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Rust是强类型语言，如果要声明变量，需要使用”let”关键字。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">123</span>;    <span class="hljs-comment">//其中，加上“mut”时变量才可被修改。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">b</span> = <span class="hljs-number">124</span>;<br>    <span class="hljs-comment">//此时a的值无法进行修改，会出错。</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;b&#125;&quot;</span>);<br>    b = <span class="hljs-number">125</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;b&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码将会输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">124<br>125<br></code></pre></td></tr></table></figure><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span> = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);    <span class="hljs-comment">//创建了一个元组绑定在tup上</span><br>    <span class="hljs-comment">//使用了 let 和一个模式将 tup 分成了三个不同的变量，x、y、z</span><br>    <span class="hljs-keyword">let</span> (x, y, z) = tup;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;y&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码会输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">6</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="数组-非vector"><a href="#数组-非vector" class="headerlink" title="数组(非vector)"></a>数组(非vector)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = a[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">second</span> = a[<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;first&#125;&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;second&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码会输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br></code></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="Loop"><a href="#Loop" class="headerlink" title="Loop"></a>Loop</h3><p>loop关键字将使代码一遍又一遍的执行，直到用户使用 停止 操作。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">loop</span>&#123;<br>        <span class="hljs-title function_ invoke__">println</span>(<span class="hljs-string">&quot;This is a loop!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码会输出：(3次后按下 Ctrl+C 使其停止)</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-string">&quot;This is a loop!&quot;</span><br><span class="hljs-string">&quot;This is a loop!&quot;</span><br><span class="hljs-string">&quot;This is a loop!&quot;</span><br><span class="hljs-symbol">^C</span><br></code></pre></td></tr></table></figure><h3 id="For"><a href="#For" class="headerlink" title="For"></a>For</h3><p>for循环遍历集合中的元素例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">elemt</span> <span class="hljs-keyword">in</span> a &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the a&#x27;s elements is &#123;elemt&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码会输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">10<br>20<br>30<br>40<br>50<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ Linux服务器多线程开发 - POSIX</title>
    <link href="/2023/04/24/C++ThreadNotes/"/>
    <url>/2023/04/24/C++ThreadNotes/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>在C++中多线程的实现方法有POSIX与C++11自带库，在本文中将使用POSIX方法。<br><br></p><h1 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h1><h3 id="首先导入库："><a href="#首先导入库：" class="headerlink" title="首先导入库："></a>首先导入库：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br></code></pre></td></tr></table></figure><br><h3 id="POSIX多线程函数基础API："><a href="#POSIX多线程函数基础API：" class="headerlink" title="POSIX多线程函数基础API："></a>POSIX多线程函数基础API：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">pthread_create</span>()    <span class="hljs-comment">//创建进程</span><br><span class="hljs-built_in">pthread_exit</span>()    <span class="hljs-comment">//线程终止自身执行</span><br><span class="hljs-built_in">pthread_join</span>()    <span class="hljs-comment">//等待一个线程的结束</span><br><span class="hljs-built_in">pthread_self</span>()    <span class="hljs-comment">//返回线程ID</span><br><span class="hljs-built_in">pthread_cancel</span>()  <span class="hljs-comment">//取消另外一个线程</span><br><span class="hljs-built_in">pthread_kill</span>()    <span class="hljs-comment">//向线程发送信号</span><br></code></pre></td></tr></table></figure><br><h3 id="创建线程函数"><a href="#创建线程函数" class="headerlink" title="创建线程函数"></a>创建线程函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *pid,<span class="hljs-type">const</span> pthread_attr_r *attr,<span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span> *),<span class="hljs-type">void</span> *arg)</span></span>;<br></code></pre></td></tr></table></figure><p>参数pid为指针，指向创建完成之后的线程ID。<br>pthread_t为unsigned long int类型。<br>attr指向线程属性结构，为pthread_attr_r的指针。<br>start_routine指向线程函数的地址。<br>arg指向传给线程函数的参数，成功为0;</p><h3 id="pthread-join的作用"><a href="#pthread-join的作用" class="headerlink" title="pthread_join的作用"></a>pthread_join的作用</h3><p>pthread_create创建完线程后，主线程仍然会执行pthread_create后面的代码，就会导致主程序已经结束了但是子线程还未创建完的情况出现，所以就需要让主线程等待，所以pthread_join则为阻塞函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> pid,<span class="hljs-type">void</span> ** value_ptr)</span></span>;<br></code></pre></td></tr></table></figure><p>value_ptr通常可以为NULL，若不为NULL，则pthread_t会复制一份线程退出值去内存区域内，并让*value_ptr指向该内存区域，所以pthread_join还能获得子线程的返回值。</p><h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">threadfunction</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> <span class="hljs-comment">//线程函数</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;in threadfunction&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">pthread_t</span> tidp;<br>    <span class="hljs-type">int</span> ret;<br>    ret = <span class="hljs-built_in">pthread_create</span>(&amp;tidp, <span class="hljs-literal">NULL</span>, threadfunction, <span class="hljs-literal">NULL</span>);    <span class="hljs-comment">//创建线程</span><br>    <span class="hljs-keyword">if</span> (ret)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;pthread_create failed:&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">//main线程挂起1秒，让子线程有机会执行。</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;in main thread created.&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码会输出如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">in threadfunction<br>in main thread created.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ Stack、Queue使用方法</title>
    <link href="/2023/04/11/C++StackQueueNotes/"/>
    <url>/2023/04/11/C++StackQueueNotes/</url>
    
    <content type="html"><![CDATA[<h1 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h1><p>先进后出，当想访问栈内某一元素时，必须将其顶部的元素都弹出出栈后，才能访问该元素。<br><br></p><h1 id="栈Stack使用方法"><a href="#栈Stack使用方法" class="headerlink" title="栈Stack使用方法"></a>栈Stack使用方法</h1><h3 id="首先导入库与定义"><a href="#首先导入库与定义" class="headerlink" title="首先导入库与定义"></a>首先导入库与定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stack&lt;type_name&gt; name;<br>    <span class="hljs-comment">//type_name可以是任何基本类型、结构体</span><br>    <span class="hljs-comment">//也可以是STL标准容器如queue、set、vector</span><br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="常用的使用方法"><a href="#常用的使用方法" class="headerlink" title="常用的使用方法"></a>常用的使用方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//移除栈顶元素</span><br>stack.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">//返回是否为空的布尔值</span><br>stack.<span class="hljs-built_in">empty</span>();<br><span class="hljs-comment">//栈顶添加元素,*代指元素</span><br>stack.<span class="hljs-built_in">push</span>(*);<br><span class="hljs-comment">//返回stack中元素的个数</span><br>stack.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//返回栈顶元素</span><br>stack.<span class="hljs-built_in">top</span>();<br></code></pre></td></tr></table></figure><br><h1 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h1><p>先进入队列的先出去，后进入队列的后出去。必须从队尾插入新元素，队列中的元素只能从队首出。<br><br></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ Set、Map使用方法</title>
    <link href="/2023/03/08/C++MapSetNotes/"/>
    <url>/2023/03/08/C++MapSetNotes/</url>
    
    <content type="html"><![CDATA[<h1 id="Map与Unordered-map的区别？"><a href="#Map与Unordered-map的区别？" class="headerlink" title="Map与Unordered_map的区别？"></a>Map与Unordered_map的区别？</h1><h4 id="map：基于红黑树，元素有序存储"><a href="#map：基于红黑树，元素有序存储" class="headerlink" title="map：基于红黑树，元素有序存储"></a>map：基于红黑树，元素有序存储<br></h4><h4 id="unordered-map：基于散列表，元素无序存储"><a href="#unordered-map：基于散列表，元素无序存储" class="headerlink" title="unordered_map：基于散列表，元素无序存储"></a>unordered_map：基于散列表，元素无序存储</h4><h4 id="在需要元素有序性或者对单次查询性能要求较为敏感时，请使用map，其余情况下应使用unordered-map，算法中更多的使用unordered-map。"><a href="#在需要元素有序性或者对单次查询性能要求较为敏感时，请使用map，其余情况下应使用unordered-map，算法中更多的使用unordered-map。" class="headerlink" title="在需要元素有序性或者对单次查询性能要求较为敏感时，请使用map，其余情况下应使用unordered_map，算法中更多的使用unordered_map。"></a>在需要元素有序性或者对单次查询性能要求较为敏感时，请使用map，其余情况下应使用unordered_map，算法中更多的使用unordered_map。</h4><br><h1 id="Set与Map的区别？"><a href="#Set与Map的区别？" class="headerlink" title="Set与Map的区别？"></a>Set与Map的区别？</h1><h3 id="点击进入查看详细"><a href="#点击进入查看详细" class="headerlink" title="点击进入查看详细"></a><a href = "https://blog.csdn.net/zzzlln/article/details/122113934">点击进入查看详细</a></h3><br><h1 id="HashMap使用方法"><a href="#HashMap使用方法" class="headerlink" title="HashMap使用方法"></a>HashMap使用方法</h1><br><h4 id="首先导入库（map）及定义"><a href="#首先导入库（map）及定义" class="headerlink" title="首先导入库（map）及定义"></a>首先导入库（map）及定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    map&lt;<span class="hljs-type">int</span>, string&gt; hashmap;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id = "insertmap"></h4><h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//三种方法，方法一 insert：</span><br>hashmap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,string&gt;(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;这是1&quot;</span>));<br><span class="hljs-comment">//方法二：</span><br>hashmap.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>,string&gt;::<span class="hljs-built_in">value_type</span> (<span class="hljs-number">2</span>,<span class="hljs-string">&quot;这是2&quot;</span>));<br><span class="hljs-comment">//方法三：</span><br>hashmap[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;这是3&quot;</span>;<br></code></pre></td></tr></table></figure><br><h4 id="遍历元素（C-11）"><a href="#遍历元素（C-11）" class="headerlink" title="遍历元素（C++ 11）"></a>遍历元素（C++ 11）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : hashmap)&#123;<br>    cout &lt;&lt; i.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i.second &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中i.first返回的是key值，i.second返回的是key值对应的value值。<br><br></p><h1 id="HashMap-unordered-map-使用方法"><a href="#HashMap-unordered-map-使用方法" class="headerlink" title="HashMap(unordered_map)使用方法"></a>HashMap(unordered_map)使用方法</h1><h4 id="首先导入库"><a href="#首先导入库" class="headerlink" title="首先导入库"></a>首先导入库</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>,string&gt; umap;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="插入元素、遍历（方法相同，点击跳转）"><a href="#插入元素、遍历（方法相同，点击跳转）" class="headerlink" title="插入元素、遍历（方法相同，点击跳转）"></a><a href="#insertmap">插入元素、遍历（方法相同，点击跳转）</a></h4><br><h1 id="HashSet使用方法"><a href="#HashSet使用方法" class="headerlink" title="HashSet使用方法"></a>HashSet使用方法</h1><h4 id="首先导入库-set-与定义"><a href="#首先导入库-set-与定义" class="headerlink" title="首先导入库(set)与定义"></a>首先导入库(set)与定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    set&lt;<span class="hljs-type">char</span>&gt; set1;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id = "insertset"></h4><h4 id="插入元素-1"><a href="#插入元素-1" class="headerlink" title="插入元素"></a>插入元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//例如我有一个 string TestCase= “Hello”</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : TestCase)&#123;<br>    set1.<span class="hljs-built_in">insert</span>(c);<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : set1)&#123;<br>    cout &lt;&lt; c;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="此时会发现输出了“Helo”，Set作用之一便是去重。"><a href="#此时会发现输出了“Helo”，Set作用之一便是去重。" class="headerlink" title="此时会发现输出了“Helo”，Set作用之一便是去重。"></a>此时会发现输出了“Helo”，Set作用之一便是去重。</h4><br><h1 id="HashSet-unorderd-set-使用方法"><a href="#HashSet-unorderd-set-使用方法" class="headerlink" title="HashSet(unorderd_set)使用方法"></a>HashSet(unorderd_set)使用方法</h1><h4 id="首先导入库与定义"><a href="#首先导入库与定义" class="headerlink" title="首先导入库与定义"></a>首先导入库与定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unorderd_set&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    unorderd_set&lt;<span class="hljs-type">char</span>&gt; uset;<br>&#125;<br></code></pre></td></tr></table></figure><br><h4 id="插入元素、遍历（方法相同，点击跳转）-1"><a href="#插入元素、遍历（方法相同，点击跳转）-1" class="headerlink" title="插入元素、遍历（方法相同，点击跳转）"></a><a href="#insertset">插入元素、遍历（方法相同，点击跳转）</a></h4><br>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java算法笔记（OUT）</title>
    <link href="/2023/01/08/MyJavaNotes/"/>
    <url>/2023/01/08/MyJavaNotes/</url>
    
    <content type="html"><![CDATA[<h1 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h1><h6 id="字符串（常用）："><a href="#字符串（常用）：" class="headerlink" title="字符串（常用）："></a>字符串（常用）：</h6><h4 id="substring：分割字符串。"><a href="#substring：分割字符串。" class="headerlink" title="substring：分割字符串。"></a>substring：分割字符串。<br></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">Example</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Caseinpoint&quot;</span>;<br>System.out.println(Example.substring(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>上方代码输出的结果是“Ca”，以此类推。<br><br></p><h4 id="equals：字符串对比。"><a href="#equals：字符串对比。" class="headerlink" title="equals：字符串对比。"></a>equals：字符串对比。<br></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">word1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">word2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>System.out.println(word2.substring(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>).equals(word1));<br></code></pre></td></tr></table></figure><p>上方代码输出的结果是“true”。<br><br></p><h4 id="toString-：输出字符串数组。"><a href="#toString-：输出字符串数组。" class="headerlink" title="toString( )：输出字符串数组。"></a>toString( )：输出字符串数组。<br></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">String[] words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;Words1&quot;</span>,<span class="hljs-string">&quot;Words2&quot;</span>&#125;; <br>System.out.println(words.toString());<br></code></pre></td></tr></table></figure><p>上方代码输出的结果是“[Words1, Words2]”。<br><br></p><h4 id="toCharArray-：转换字符串为字符数组。"><a href="#toCharArray-：转换字符串为字符数组。" class="headerlink" title="toCharArray( )：转换字符串为字符数组。"></a>toCharArray( )：转换字符串为字符数组。<br></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>; <br><span class="hljs-type">char</span>[] words = word.toCharArray();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> i : words) &#123;<br>System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>上方代码输出的结果是“H、e、l、l、o”,此处顿号代表换行。<br><br></p><h6 id="字符（常用）："><a href="#字符（常用）：" class="headerlink" title="字符（常用）："></a>字符（常用）：</h6><h4 id="Character-isDigit：判断字符是否为数字。"><a href="#Character-isDigit：判断字符是否为数字。" class="headerlink" title="Character.isDigit：判断字符是否为数字。"></a>Character.isDigit：判断字符是否为数字。<br></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">char</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;T&#x27;</span>;<br>System.out.println(Character.isDigit(A));<br>System.out.println(Character.isDigit(B));<br></code></pre></td></tr></table></figure><p>上方代码输出的结果是“true与false”。<br><br></p><h6 id="哈希表："><a href="#哈希表：" class="headerlink" title="哈希表："></a>哈希表：</h6><h4 id="HashMap使用方法："><a href="#HashMap使用方法：" class="headerlink" title="HashMap使用方法："></a>HashMap使用方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-number">1.</span> Map&lt;Integer, String&gt; Sites = Map.of(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">2</span>,<span class="hljs-string">&quot;Nihao&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Hola&quot;</span>);<br><br><span class="hljs-number">2.</span> HashMap&lt;Integer, String&gt; Sites = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, String&gt;();<br>   Sites.put(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Hello&quot;</span>);<br>   Sites.put(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Nihao&quot;</span>);<br>   Sites.put(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Hola&quot;</span>);<br></code></pre></td></tr></table></figure><p>如以上两种方法所示，以打印的方式输出后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">System.out.println(Sites);<br></code></pre></td></tr></table></figure><p>结果都是同样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">&#123;<span class="hljs-number">1</span>=Hello, <span class="hljs-number">2</span>=Nihao, <span class="hljs-number">3</span>=Hola&#125;<br></code></pre></td></tr></table></figure><p>Hashmap访问(结果为”Nihao”)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">System.out.println(Sites.get(<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>Hashmap移除元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">Sites.remove(<span class="hljs-number">2</span>);<br>System.out.println(Sites);<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">&#123;<span class="hljs-number">1</span>=Hello,<span class="hljs-number">3</span>=Hola&#125;<br></code></pre></td></tr></table></figure><br>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Steam饰品搬砖手动选品利润计算器 v0.9.6 发布</title>
    <link href="/2022/09/20/ManualSelectionTool096/"/>
    <url>/2022/09/20/ManualSelectionTool096/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Steam饰品搬砖？"><a href="#什么是Steam饰品搬砖？" class="headerlink" title="什么是Steam饰品搬砖？"></a>什么是Steam饰品搬砖？</h2><h5 id="Steam饰品搬砖就是通过第三方折扣后购买Steam美金余额卡，充值Steam余额，进行大批量饰品购买，再通过国内第三方交易平台以正常价售出；其软件则计算该过程中赚取的差价，简单的说就是，低价买入高价售出，称作为搬砖。"><a href="#Steam饰品搬砖就是通过第三方折扣后购买Steam美金余额卡，充值Steam余额，进行大批量饰品购买，再通过国内第三方交易平台以正常价售出；其软件则计算该过程中赚取的差价，简单的说就是，低价买入高价售出，称作为搬砖。" class="headerlink" title="Steam饰品搬砖就是通过第三方折扣后购买Steam美金余额卡，充值Steam余额，进行大批量饰品购买，再通过国内第三方交易平台以正常价售出；其软件则计算该过程中赚取的差价，简单的说就是，低价买入高价售出，称作为搬砖。"></a>Steam饰品搬砖就是通过第三方折扣后购买Steam美金余额卡，充值Steam余额，进行大批量饰品购买，再通过国内第三方交易平台以正常价售出；其软件则计算该过程中赚取的差价，简单的说就是，低价买入高价售出，称作为搬砖。</h5><hr><h2 id="软件截图："><a href="#软件截图：" class="headerlink" title="软件截图："></a>软件截图：</h2><p><img src="/images/blogimages/mst096.png" alt="软件截图"></p><hr><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><h5 id="1-若在使用时发现错误，请在Issues报告，可能会尽快修复。"><a href="#1-若在使用时发现错误，请在Issues报告，可能会尽快修复。" class="headerlink" title="1.若在使用时发现错误，请在Issues报告，可能会尽快修复。"></a>1.若在使用时发现错误，请在Issues报告，可能会尽快修复。</h5><h5 id="2-实时美元汇率为1美元的当前汇率；充值折扣请按照小数点方式填写-例如7折请填”0-7”或”0-70”；Buff出售价格以及Steam购入价格请按照美元的价格填写。"><a href="#2-实时美元汇率为1美元的当前汇率；充值折扣请按照小数点方式填写-例如7折请填”0-7”或”0-70”；Buff出售价格以及Steam购入价格请按照美元的价格填写。" class="headerlink" title="2.实时美元汇率为1美元的当前汇率；充值折扣请按照小数点方式填写,例如7折请填”0.7”或”0.70”；Buff出售价格以及Steam购入价格请按照美元的价格填写。"></a>2.实时美元汇率为1美元的当前汇率；充值折扣请按照小数点方式填写,例如7折请填”0.7”或”0.70”；Buff出售价格以及Steam购入价格请按照美元的价格填写。</h5><h5 id="3-利润算法仅靠自己研究发现，不保证100-准确，造成任何经济损失请自行承担。"><a href="#3-利润算法仅靠自己研究发现，不保证100-准确，造成任何经济损失请自行承担。" class="headerlink" title="3.利润算法仅靠自己研究发现，不保证100%准确，造成任何经济损失请自行承担。"></a>3.利润算法仅靠自己研究发现，不保证100%准确，造成任何经济损失请自行承担。</h5><h5 id="4-该软件由Python-Tkinter提供GUI，完全开源，仅提供计算“Steam饰品搬砖商品选择上的利润”-不涉及任何利益！"><a href="#4-该软件由Python-Tkinter提供GUI，完全开源，仅提供计算“Steam饰品搬砖商品选择上的利润”-不涉及任何利益！" class="headerlink" title="4.该软件由Python Tkinter提供GUI，完全开源，仅提供计算“Steam饰品搬砖商品选择上的利润”,不涉及任何利益！"></a>4.该软件由Python Tkinter提供GUI，完全开源，仅提供计算“Steam饰品搬砖商品选择上的利润”,不涉及任何利益！</h5><hr><h2 id="v0-9-6更新日志："><a href="#v0-9-6更新日志：" class="headerlink" title="v0.9.6更新日志："></a>v0.9.6更新日志：</h2><h5 id="1-优化代码逻辑，修复了启动提示选择“否”时出现报错"><a href="#1-优化代码逻辑，修复了启动提示选择“否”时出现报错" class="headerlink" title="1.优化代码逻辑，修复了启动提示选择“否”时出现报错"></a>1.优化代码逻辑，修复了启动提示选择“否”时出现报错</h5><h5 id="2-新增”启动提示”"><a href="#2-新增”启动提示”" class="headerlink" title="2.新增”启动提示”"></a>2.新增”启动提示”</h5><h5 id="3-修改API源-优化了不同网络访问速度"><a href="#3-修改API源-优化了不同网络访问速度" class="headerlink" title="3.修改API源,优化了不同网络访问速度"></a>3.修改API源,优化了不同网络访问速度</h5><h5 id="4-额外添加了1条备用API"><a href="#4-额外添加了1条备用API" class="headerlink" title="4.额外添加了1条备用API"></a>4.额外添加了1条备用API</h5><h5 id="5-添加应用Logo"><a href="#5-添加应用Logo" class="headerlink" title="5.添加应用Logo"></a>5.添加应用Logo</h5><hr><h2 id="已知Bug"><a href="#已知Bug" class="headerlink" title="已知Bug:"></a>已知Bug:</h2><h5 id="1-短期内多次打开应用可能会出现错误-尽量避免反复多次打开，新的汇率API有限制"><a href="#1-短期内多次打开应用可能会出现错误-尽量避免反复多次打开，新的汇率API有限制" class="headerlink" title="1.短期内多次打开应用可能会出现错误(尽量避免反复多次打开，新的汇率API有限制)"></a>1.短期内多次打开应用可能会出现错误(尽量避免反复多次打开，新的汇率API有限制)</h5><hr><h3 id="下载地址：Github"><a href="#下载地址：Github" class="headerlink" title="下载地址：Github"></a>下载地址：<a href="https://github.com/ClaretWheel1481/Manual-Selection-Tool-Python-Version/releases">Github</a></h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Steam饰品搬砖手动选品利润计算器 v0.9.4 发布</title>
    <link href="/2022/08/04/ManualSelectionTool094/"/>
    <url>/2022/08/04/ManualSelectionTool094/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Steam饰品搬砖？"><a href="#什么是Steam饰品搬砖？" class="headerlink" title="什么是Steam饰品搬砖？"></a>什么是Steam饰品搬砖？</h2><h5 id="Steam饰品搬砖就是通过第三方折扣后购买Steam美金余额卡，充值Steam余额，进行大批量饰品购买，再通过国内第三方交易平台以正常价售出；其软件则计算该过程中赚取的差价，简单的说就是，低价买入高价售出，称作为搬砖。"><a href="#Steam饰品搬砖就是通过第三方折扣后购买Steam美金余额卡，充值Steam余额，进行大批量饰品购买，再通过国内第三方交易平台以正常价售出；其软件则计算该过程中赚取的差价，简单的说就是，低价买入高价售出，称作为搬砖。" class="headerlink" title="Steam饰品搬砖就是通过第三方折扣后购买Steam美金余额卡，充值Steam余额，进行大批量饰品购买，再通过国内第三方交易平台以正常价售出；其软件则计算该过程中赚取的差价，简单的说就是，低价买入高价售出，称作为搬砖。"></a>Steam饰品搬砖就是通过第三方折扣后购买Steam美金余额卡，充值Steam余额，进行大批量饰品购买，再通过国内第三方交易平台以正常价售出；其软件则计算该过程中赚取的差价，简单的说就是，低价买入高价售出，称作为搬砖。</h5><hr><h2 id="软件截图："><a href="#软件截图：" class="headerlink" title="软件截图："></a>软件截图：</h2><p><img src="/images/blogimages/mst094.png" alt="软件截图"></p><hr><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><h5 id="1-请尽量在中国互联网的环境下打开该软件-或暂停使用VPN-，否则将启动速度缓慢或无法正常打开-用于查询当前时间的美元汇率-。"><a href="#1-请尽量在中国互联网的环境下打开该软件-或暂停使用VPN-，否则将启动速度缓慢或无法正常打开-用于查询当前时间的美元汇率-。" class="headerlink" title="1.请尽量在中国互联网的环境下打开该软件(或暂停使用VPN)，否则将启动速度缓慢或无法正常打开(用于查询当前时间的美元汇率)。"></a>1.请尽量在中国互联网的环境下打开该软件(或暂停使用VPN)，否则将启动速度缓慢或无法正常打开(用于查询当前时间的美元汇率)。</h5><h5 id="2-若在使用时发现错误，请在Issues报告，可能会尽快修复。"><a href="#2-若在使用时发现错误，请在Issues报告，可能会尽快修复。" class="headerlink" title="2.若在使用时发现错误，请在Issues报告，可能会尽快修复。"></a>2.若在使用时发现错误，请在Issues报告，可能会尽快修复。</h5><h5 id="3-实时美元汇率为1美元的当前汇率；充值折扣请按照小数点方式填写-例如7折请填”0-7”或”0-70”；Buff出售价格以及Steam购入价格请按照美元的价格填写。"><a href="#3-实时美元汇率为1美元的当前汇率；充值折扣请按照小数点方式填写-例如7折请填”0-7”或”0-70”；Buff出售价格以及Steam购入价格请按照美元的价格填写。" class="headerlink" title="3.实时美元汇率为1美元的当前汇率；充值折扣请按照小数点方式填写,例如7折请填”0.7”或”0.70”；Buff出售价格以及Steam购入价格请按照美元的价格填写。"></a>3.实时美元汇率为1美元的当前汇率；充值折扣请按照小数点方式填写,例如7折请填”0.7”或”0.70”；Buff出售价格以及Steam购入价格请按照美元的价格填写。</h5><h5 id="4-利润算法仅靠自己研究发现，不保证100-准确，造成任何经济损失请自行承担。"><a href="#4-利润算法仅靠自己研究发现，不保证100-准确，造成任何经济损失请自行承担。" class="headerlink" title="4.利润算法仅靠自己研究发现，不保证100%准确，造成任何经济损失请自行承担。"></a>4.利润算法仅靠自己研究发现，不保证100%准确，造成任何经济损失请自行承担。</h5><h5 id="5-该软件由Python-Tkinter提供GUI，完全开源，仅提供计算“Steam饰品搬砖商品选择上的利润”-不涉及任何利益！"><a href="#5-该软件由Python-Tkinter提供GUI，完全开源，仅提供计算“Steam饰品搬砖商品选择上的利润”-不涉及任何利益！" class="headerlink" title="5.该软件由Python Tkinter提供GUI，完全开源，仅提供计算“Steam饰品搬砖商品选择上的利润”,不涉及任何利益！"></a>5.该软件由Python Tkinter提供GUI，完全开源，仅提供计算“Steam饰品搬砖商品选择上的利润”,不涉及任何利益！</h5><hr><h2 id="v0-9-4更新日志："><a href="#v0-9-4更新日志：" class="headerlink" title="v0.9.4更新日志："></a>v0.9.4更新日志：</h2><h5 id="1-移除Random库-加速启动。"><a href="#1-移除Random库-加速启动。" class="headerlink" title="1.移除Random库,加速启动。"></a>1.移除Random库,加速启动。</h5><h5 id="2-小幅度优化GUI。"><a href="#2-小幅度优化GUI。" class="headerlink" title="2.小幅度优化GUI。"></a>2.小幅度优化GUI。</h5><hr><h2 id="已知Bug"><a href="#已知Bug" class="headerlink" title="已知Bug:"></a>已知Bug:</h2><h5 id="1-短期内多次打开应用可能会出现错误-尽量避免反复多次打开，新的汇率API有限制"><a href="#1-短期内多次打开应用可能会出现错误-尽量避免反复多次打开，新的汇率API有限制" class="headerlink" title="1.短期内多次打开应用可能会出现错误(尽量避免反复多次打开，新的汇率API有限制)"></a>1.短期内多次打开应用可能会出现错误(尽量避免反复多次打开，新的汇率API有限制)</h5><hr><h3 id="下载地址：Github"><a href="#下载地址：Github" class="headerlink" title="下载地址：Github"></a>下载地址：<a href="https://github.com/ClaretWheel1481/Manual-Selection-Tool-Python-Version/releases/tag/v0.9.4">Github</a></h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>笔记本处理器优化[Intel]</title>
    <link href="/2022/08/04/LaptopOpt/"/>
    <url>/2022/08/04/LaptopOpt/</url>
    
    <content type="html"><![CDATA[<p>随着时间推移，笔记本逐渐成为人们生活中的一部分。而随着处理器厂商之间的内卷，性能增强的代价则是越来越高的发热与功耗。而这一篇文章，讲述的则是如何使Intel移动端处理器在合适的场合拥有合适的性能与功耗。<br>#</p><h2 id="软件部分："><a href="#软件部分：" class="headerlink" title="软件部分："></a>软件部分：</h2><p>此处以”i5-11400H”作为演示（每颗CPU设置也许不同，仅作为参考）</p><p>下滑找到下方三栏分别为：</p><p>1.Turbo Boost Short Power Max</p><p>2.Turbo Boost Power Max</p><p>3.Turbo Boost Power Time Window</p><p><img src="/images/blogimages/XTU.png" alt="图片展示"></p><p>在这里，我们仅需要调整第2条 - Turbo Boost Power Max</p><p>根据不同场景限制其功耗，能够有效降低温度，且也有所需要的性能。</p><p>以“原神”为例（原神锁60FPS不需要太多性能）：</p><p>我将 Turbo Boost Power Max 功耗设置为“Unlimited”，此时游戏帧数处于60FPS，但温度已经上了75度，且风扇呼呼的转。</p><p><img src="/images/blogimages/GUnlimited.png" alt="图片展示"></p><p>而将 Turbo Boost Power Max 功耗限制为“12.000W”，而此时游戏帧数仍然处于60FPS，整体功耗都下来了且安静许多。</p><p><img src="/images/blogimages/Glimited.png" alt="图片展示"><br>#</p><h2 id="硬件部分："><a href="#硬件部分：" class="headerlink" title="硬件部分："></a>硬件部分：</h2><p>要想拥有更好的性能与更低的发热，更换硅脂也是一个好方法。</p><p>笔记本出厂涂抹的硅脂大部分导热性能都比较差，此处推荐几个平价硅脂或相变片，笔记本对应型号更换教程也可以在网络上查询。</p><p><em>Arctic MX-4</em></p><p><em>信越 7921 &#x2F; 7868</em></p><p><em>利民 TF7</em></p><p><em>霍尼韦尔 7950 相变片</em></p><p>注意：使用相变片刚开始温度会较高，但是随着时间增长温度会下降到一定程度，效果可能比硅脂更好。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于我的Firefox配置</title>
    <link href="/2022/08/04/AboutMyFirefox/"/>
    <url>/2022/08/04/AboutMyFirefox/</url>
    
    <content type="html"><![CDATA[<p>Firefox我最喜欢的地方就是它的开源与高度自定义；以下则是我对Firefox进行的部分配置。</p><h2 id="插件："><a href="#插件：" class="headerlink" title="插件："></a>插件：</h2><p>我最喜欢且常用的插件是 <em>ublock Origin</em> 与 <em>Dark Reader</em>。</p><ul><li><em>ublock Origin</em></li></ul><p>Firefox自带的跟踪保护，却没有广告拦截功能，而 <em>ublock Origin</em> 恰好弥补了这个缺点，它体积小还支持导入规则或自定义，优化加载网页的速度。</p><p>附上整合了乘风视频广告过滤规则、EasylistChina、EasylistLite、CJX’sAnnoyance的规则：</p><p><code>https://cdn.jsdelivr.net/gh/o0HalfLife0o/list@master/ad.txt</code></p><ul><li><em>Dark Reader</em></li></ul><p>Dark Reader让我在浏览网页时，减轻了我的眼睛负担。</p><p>我时常在深夜开着一盏台灯浏览密密麻麻的资料，系统主题为深色，而打开的部分网页却是白色，非常瞎眼，而这个插件则可以动态识别网页元素并修改为合适的深色，不仅如此还可以修改网页字体并加粗；还有很多功能都非常实用，也不会吃很多性能，值得推荐。</p><p><img src="/images/blogimages/darkreader.png" alt="图片展示"></p><h2 id="About-config："><a href="#About-config：" class="headerlink" title="About:config："></a>About:config：</h2><ul><li><em>页面滚动</em></li></ul><p>我一直觉得Firefox的页面滚动异常让我不舒服，隔壁Edge的页面滚动轻快但是油腻，直到我在Firefox的配置中发现了一个选项，打开后让Firefox实现了拥有Edge的轻快还没了Edge的油腻。</p><p>在地址栏中输入about:config后，再搜索：</p><p><code>general.smoothScroll.msdPhysics.enabled</code></p><p>将 <em>False</em> 修改为 <em>True</em> </p><p>之后用滚轮滚动页面会发现十分跟手！</p><ul><li><em>字体渲染</em></li></ul><p>Firefox渲染出的字体在1080p下比Chromium系渲染出的字体要粗且更清晰，但是我还想更好，于是经过我的不断搜索挖掘中发现：</p><p>在地址栏中输入about:config后，再搜索：</p><p><code>gfx.font_rendering.cleartype_params.rendering_mode</code></p><p>将数值改为 <em>5</em></p><p><code>0=default，1=aliased，2=GDI Classic，3=GDI Natural，4=Natural，5=Natural Symmetric</code></p><p>你会发现字体渲染与Linux平台的Firefox中字体十分相似，对我而言看着更舒服。</p><p>如果想要更好的效果，可以尝试搭配<a href="https://github.com/snowie2000/mactype">Mactype</a>实现“Mac”的字体渲染。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
